<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GIT Operation</title>
    <url>/2020/09/08/git/</url>
    <content><![CDATA[<h4 id="git流程图"><a href="#git流程图" class="headerlink" title="git流程图"></a>git流程图</h4><p><img src="/image/640.png" alt="avatar"></p>
<ul>
<li>Workspace 工作区</li>
<li>Staging/Index：暂存区</li>
<li>Local Repository：本地仓库（可修改）</li>
<li>/refs/remotes：远程仓库的引用（不可修改）</li>
<li>Remote：远程仓库</li>
</ul>
<h4 id="git简单命令"><a href="#git简单命令" class="headerlink" title="git简单命令"></a>git简单命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 在当前目录新建一个git仓库<br>git init<br><br># 打开git仓库图形界面<br>gitk<br><br># 显示所有变更信息<br>git status<br><br># 删除所有Untracked files<br>git clean -fd<br><br># 下载远程仓库的所有更新<br>git fetch remote<br><br># 下载远程仓库的所有更新，并且Merge<br>git pull romote branch-name<br><br><br># 查看上次commit id<br>git rev-parse HEAD <br><br># 将指定分支合并到当前分支<br>git merge branch-name<br><br># 将最近的一次commit打包到patch文件中<br>git format-patch HEAD^ <br><br># 将patch文件 添加到本地仓库<br>git am  patch-file<br><br># 查看指定文件修改历史<br>git blame file-name<br><br></code></pre></td></tr></table></figure>

<ul>
<li>git clone</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 将远程git仓库克隆到本地<br>git clone url<br><br># 将远程git仓库克隆到本地<br>git clone -b branch url <br><br></code></pre></td></tr></table></figure>

<ul>
<li>git stash</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 将修改过，未add到Staging区的文件，暂时存储起来<br>git stash<br><br># 恢复之前stash存储的内容<br>git stash apply<br><br># 保存stash 并写message<br>git stash save &quot;stash test&quot;<br><br># 查看stash了哪些存储<br>git stash list<br><br># 将stash@&#123;1&#125;存储的内容还原到工作区<br>git stash apply stash@&#123;1&#125;<br><br># 删除stash@&#123;1&#125;存储的内容<br>git stash drop stash@&#123;1&#125;<br><br># 删除所有缓存的stash<br>git stash clear<br><br><br></code></pre></td></tr></table></figure>

<ul>
<li>git config</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 配置git图形界面编码为utf-8<br>git config --global gui.encoding&#x3D;utf-8 <br><br># 设置全局提交代码的用户名 <br>git config --global user.name name  <br><br># 设置全局提交代码时的邮箱<br>git config --global user.email email<br><br># 设置当前项目提交代码的用户名 <br>git config user.name name  <br><br></code></pre></td></tr></table></figure>

<ul>
<li>git remote</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 显示所有远程仓库<br>git remote -v  <br><br>#  增加一个新的远程仓库<br>git remote add name url <br><br>#  删除指定远程仓库<br>git remote remove name<br><br># 获取指定远程仓库的详细信息<br>git remote show origin<br><br></code></pre></td></tr></table></figure>

<ul>
<li>git add</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 添加所有的修改到Staging区<br>git add .<br>git add --all  <br><br># 添加指定文件到Staging区<br>git add file   <br><br># 添加多个修改的文件到Staging区<br>git add file1 file2   <br><br># 添加修改的目录到Staging区<br>git add dir<br><br># 添加所有src目录下main开头的所有文件到Staging区    <br>git add src&#x2F;main* <br><br></code></pre></td></tr></table></figure>

<ul>
<li>git commit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 提交Staging区的代码到本地仓库区<br>git commit -m &quot;message&quot;  <br><br># 提交Staging中在指定文件到本地仓库区<br>git commit file1 file2 -m &quot;message&quot;  <br><br># 使用新的一次commit，来覆盖上一次commit<br>git commit --amend -m &quot;message&quot; <br><br># 修改上次提交的用户名和邮箱<br>git commit --amend --author&#x3D;&quot;name &lt;email&gt;&quot; --no-edit<br><br></code></pre></td></tr></table></figure>

<ul>
<li>git branch</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 列出本地所有分支<br>git branch   <br><br># 列出本地所有分支 并显示最后一次提交的哈希值<br>git branch -v<br><br># 在-v 的基础上 并且显示上游分支的名字<br>git branch -vv<br><br># 列出上游所有分支<br>git branch -r  <br><br># 新建一个分支，但依然停留在当前分支<br>git branch branch-name  <br><br># 删除分支<br>git branch -d branch-name   <br><br># 设置分支上游<br>git branch --set-upstream-to origin&#x2F;master<br><br># 本地分支重命名<br>git branch -m old-branch new-branch<br><br></code></pre></td></tr></table></figure>

<ul>
<li>git checkout</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 创建本地分支并关联远程分支<br>git checkout -b local-branch origin&#x2F;remote-branch<br><br># 新建一个分支，且切换到新分支<br>git checkout -b branch-name<br><br># 切换到另一个分支<br>git checkout branch-name  <br><br># 撤销工作区文件的修改，跟上次Commit一样<br>git checkout commit-file <br><br></code></pre></td></tr></table></figure>

<ul>
<li>git tag</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 创建带有说明的标签<br>git tag -a v1.4 -m &#39;my version 1.4&#39;<br><br>#  打标签<br>git tag tag-name<br><br># 查看所有标签<br>git tag <br><br># 给指定commit打标签<br>git tag tag-name commit-id<br><br># 删除标签<br>git tag -d tag-name <br><br></code></pre></td></tr></table></figure>

<ul>
<li>git push</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 删除远程分支<br>git push origin :master   <br><br>#  删除远程标签<br>git push origin --delete tag tag-name<br><br># 上传本地仓库到远程分支<br>git push remote branch-name<br><br># 强行推送当前分支到远程分支<br>git push remote branch-name --force<br><br># 推送所有分支到远程仓库<br>git push remote --all  <br><br># 推送所有标签<br>git push --tags<br><br># 推送指定标签<br>git push origin tag-name<br><br>#  删除远程标签（需要先删除本地标签）<br>git push origin :refs&#x2F;tags&#x2F;tag-name  <br><br># 将本地dev分支push到远程master分支<br>git push origin dev:master<br><br></code></pre></td></tr></table></figure>

<ul>
<li>git reset </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 将未commit的文件移出Staging区<br>git reset HEAD<br><br># 重置Staging区与上次commit的一样<br>git reset --hard  <br><br># 重置Commit代码和远程分支代码一样<br>git reset --hard origin&#x2F;master<br><br># 回退到上个commit<br>git reset --hard HEAD^<br><br># 回退到前3次提交之前，以此类推，回退到n次提交之前<br>git reset --hard HEAD~3<br><br>回退到指定commit<br>git reset --hard commit-id   <br><br></code></pre></td></tr></table></figure>

<ul>
<li>git diff</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 查看文件在工作区和暂存区区别<br>git diff file-name<br><br># 查看暂存区和本地仓库区别<br>git diff --cached  file-name<br><br># 查看文件和另一个分支的区别<br>git diff branch-name file-name<br><br># 查看两次提交的区别<br>git diff commit-id commit-id  <br><br></code></pre></td></tr></table></figure>

<ul>
<li>git show</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 查看指定标签的提交信息<br>git show tag-name<br><br># 查看具体的某次改动<br>git show commit-id <br><br></code></pre></td></tr></table></figure>

<ul>
<li>git rebase</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 将指定分支合并到当前分支<br>git rebase branch-name<br><br># 执行commit id 将rebase 停留在指定commit 处<br>git rebase -i commit-id<br><br># 执行commit id 将rebase 停留在 项目首次commit处<br>git rebase -i --root<br><br></code></pre></td></tr></table></figure>

<ul>
<li>git restore</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 恢复第一次add 的文件，同 git rm --cached<br>git restore --staged file<br><br># 移除staging区的文件，同 git checkout<br>git restore file<br><br></code></pre></td></tr></table></figure>

<ul>
<li>git revert</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 撤销前一次commit<br>git revert HEAD<br><br># 撤销前前一次commit<br>git revert HEAD^<br><br># 撤销指定某次commit<br>git revert commit-id<br><br></code></pre></td></tr></table></figure>

<h4 id="git-特殊情况操作"><a href="#git-特殊情况操作" class="headerlink" title="git 特殊情况操作"></a>git 特殊情况操作</h4><ul>
<li>代码没完成切换分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 暂存未提交的代码<br>git stash<br><br># 还原暂存的代码<br>git stash apply<br><br></code></pre></td></tr></table></figure>

<ul>
<li>本地临时代码不想提交，一次性清空</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 还原未commit的本地更改的代码<br>git reset --hard<br><br># 还原包含commit的代码，到跟远程分支相同<br>git reset --hard origin&#x2F;master<br><br></code></pre></td></tr></table></figure>

<ul>
<li>已经提交的代码，不需要了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 还原到上次commit<br>git reset --hard HEAD^<br><br># 还原到当前之前的几次commit<br>git reset --hard HEAD~2<br><br># 强制推送到远程分支，确保没有其他人在push，不然可能会丢失代码<br>git push origin develop --force<br><br></code></pre></td></tr></table></figure>

<ul>
<li>git reset –hard 命令，执行错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br># 误操作<br>git reset --hard 8529cb7<br><br># 执行<br>git reflog<br><br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>React Recoil 简单使用总结</title>
    <url>/2020/09/04/reactRecoil/</url>
    <content><![CDATA[<h3 id="Recoil-Facebook-官方-React-状态管理器"><a href="#Recoil-Facebook-官方-React-状态管理器" class="headerlink" title="Recoil  Facebook 官方 React 状态管理器"></a><a href="https://recoiljs.org/docs/introduction/motivation">Recoil</a>  Facebook 官方 React 状态管理器</h3><p>解决问题： 跨组件状态共享</p>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">   <br>atom()                            定义状态 <br>selector()                        定义依赖状态&#x2F;异步状态 <br>useRecoilValue(state)             仅读状态  const a &#x3D; useRecoilState(state)<br>useRecoilState(state)             读写状态  const [a, setA] &#x3D; useRecoilState(state)<br>useSetRecoilState(state)          写入状态  const setA &#x3D; useSetRecoilState(state);  setA(a) <br>useResetRecoilState(state)        状态重置初始化值 <br>useRecoilValueLoadable(state)     读取异步状态的值<br>useRecoilStateLoadable(state)     读写异步状态的值<br><br></code></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用Recoil，最外层包裹RecoilRoot（一般在app），这个和大部分状态管理器一致，通过 context 来跨组件传递数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>import React from &#39;react&#39;;<br>import &#123; RecoilRoot &#125; from &#39;recoil&#39;;<br><br>function App() &#123;<br>  return (<br>    &lt;RecoilRoot&gt;<br>        ...<br>    &lt;&#x2F;RecoilRoot&gt;<br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="跨组件状态共享"><a href="#跨组件状态共享" class="headerlink" title="跨组件状态共享"></a>跨组件状态共享</h4><p>在 Recoil 中，通过 atom 来定义一个状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>const inputValueState &#x3D; atom(&#123;<br>  key: &quot;inputValue&quot;,<br>  default: &quot;&quot;<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<p>通过 useRecoilState 来消费状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>import React from &quot;react&quot;;<br>import &#123; useRecoilState &#125; from &quot;recoil&quot;;<br>import &#123; inputValue &#125; from &quot;..&#x2F;store&quot;;<br><br>const InputA &#x3D; () &#x3D;&gt; &#123;<br>  const [value, setValue] &#x3D; useRecoilState(inputValueState);<br><br>  return &lt;input value&#x3D;&#123;value&#125; onChange&#x3D;&#123;e &#x3D;&gt; setValue(e.target.value)&#125; &#x2F;&gt;;<br>&#125;;<br><br>export default InputA;<br><br></code></pre></td></tr></table></figure>

<h4 id="状态依赖"><a href="#状态依赖" class="headerlink" title="状态依赖"></a>状态依赖</h4><p>有些状态需要依赖其它状态，通过 selector 来定义这个状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const filterdInputValue &#x3D; selector(&#123;<br>  key: &quot;filterdInputValue&quot;,<br>  get: (&#123;get&#125;) &#x3D;&gt; &#123;<br>    &#x2F;&#x2F; 通过 get 可以读取其它状态<br>    const inputValue &#x3D; get(inputValueState);<br>    return inputValue.replace(&#x2F;[0-9]&#x2F;ig, &quot;&quot;);<br>  &#125;,<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<h4 id="异步情况"><a href="#异步情况" class="headerlink" title="异步情况"></a>异步情况</h4><p>Recoil 提供了一个 useRecoilValueLoadable 来处理异步请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>const currentUserNameQuery &#x3D; selector(&#123;<br>  key: &quot;CurrentUserName&quot;,<br>  get: async () &#x3D;&gt; &#123;<br>    const response &#x3D; await queryUserInfo();<br>    return response.name;<br>  &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure>
<p>需要通过 selector 来定义异步状态，如果 get 函数是一个 Promise，则代表该状态为异步状态，需要使用 useRecoilValueLoadable 来消费该状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>const UserName &#x3D; () &#x3D;&gt; &#123;<br>  const userNameLoadable &#x3D; useRecoilValueLoadable(currentUserNameQuery);<br>  switch (userNameLoadable.state) &#123;<br>    case &quot;hasValue&quot;:<br>      return &lt;div&gt;&#123;userNameLoadable.contents&#125;&lt;&#x2F;div&gt;;<br>    case &quot;loading&quot;:<br>      return &lt;div&gt;Loading...&lt;&#x2F;div&gt;;<br>    case &quot;hasError&quot;:<br>      throw userNameLoadable.contents;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="消费状态情况"><a href="#消费状态情况" class="headerlink" title="消费状态情况"></a>消费状态情况</h4><p>消费一个状态的时候，需要 import 两个东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>import &#123; useRecoilState &#125; from &quot;recoil&quot;;<br>import &#123; inputValueState &#125; from &quot;..&#x2F;store&quot;;<br><br>&#x2F;&#x2F; 用法<br>useRecoilState(inputValueState);<br><br></code></pre></td></tr></table></figure>

<p>也可以直接通过字符串 key 消费的，但这样和 redux 问题一样了，无法支持 ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>import &#123; useRecoilState &#125; from &quot;recoil&quot;;<br>useRecoilState(&#39;inputValueState&#39;);<br><br></code></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>React Hook conclusion</title>
    <url>/2020/09/04/reactHook/</url>
    <content><![CDATA[<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p>
<h2 id="Hook-和函数组件"><a href="#Hook-和函数组件" class="headerlink" title="Hook 和函数组件"></a>Hook 和函数组件</h2><p><strong>Hook 是什么？</strong> Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。稍后我们将学习其他 Hook。</p>
<p><strong>什么时候我会用 Hook？</strong> 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">function Example(props) &#123;<br>  &#x2F;&#x2F; 你可以在这使用 Hook<br>  return &lt;div &#x2F;&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之前把它们叫做“无状态组件”。<br>但现在我们为它们引入了使用 React state 的能力，所以我们叫它”函数组件”。</p>
<h2 id="State-Hook-（基础-hook）"><a href="#State-Hook-（基础-hook）" class="headerlink" title="State Hook （基础 hook）"></a>State Hook （基础 hook）</h2><p>useState() 方法里面唯一的参数就是 <strong>初始 state</strong><br>useState() 返回值为当前 <strong>state</strong> 以及更新 __state 的函数__。<br>ex: const [count, setCount] = useState()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import React, &#123; useState &#125; from &#39;react&#39;;<br><br>function Example() &#123;<br>  &#x2F;&#x2F; 声明一个叫 “count” 的 state 变量。<br>  const [count, setCount] &#x3D; useState(0);<br><br>  return (<br>    &lt;div&gt;<br>      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;<br>        Click me<br>      &lt;&#x2F;button&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">class Example extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props);<br>    this.state &#x3D; &#123;<br>      count: 0<br>    &#125;;<br>  &#125;<br><br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;&#x2F;p&gt;<br>        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;<br>          Click me<br>        &lt;&#x2F;button&gt;<br>      &lt;&#x2F;div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Effect-Hook-（基础-hook）"><a href="#Effect-Hook-（基础-hook）" class="headerlink" title="Effect Hook （基础 hook）"></a>Effect Hook （基础 hook）</h2><p>Effect Hook 可以让你在函数组件中执行副作用操作<br>可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;<br><br>function Example() &#123;<br>  const [count, setCount] &#x3D; useState(0);<br><br>  &#x2F;&#x2F; Similar to componentDidMount and componentDidUpdate:<br>  useEffect(() &#x3D;&gt; &#123;<br>    &#x2F;&#x2F; Update the document title using the browser API<br>    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;<br>  &#125;);<br><br>  return (<br>    &lt;div&gt;<br>      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;<br>        Click me<br>      &lt;&#x2F;button&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>为什么要在 effect 中返回一个函数？</strong> 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p>
<p><strong>React 何时清除 effect？</strong>  React 会在组件卸载的时候执行清除操作。effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。如不需要清除 不需要返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;<br><br>function FriendStatus(props) &#123;<br>  const [isOnline, setIsOnline] &#x3D; useState(null);<br><br>  useEffect(() &#x3D;&gt; &#123;<br>    function handleStatusChange(status) &#123;<br>      setIsOnline(status.isOnline);<br>    &#125;<br>    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);<br>    &#x2F;&#x2F; Specify how to clean up after this effect:<br>    return function cleanup() &#123;<br>      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;<br>    return &#39;Loading...&#39;;<br>  &#125;<br>  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>effect 第二个参数</strong><br>在参数值改变时执行 effect<br>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），传一空数组（[]）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">useEffect(() &#x3D;&gt; &#123;<br>  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;<br>&#125;, [count]); &#x2F;&#x2F; 仅在 count 更改时更新<br></code></pre></td></tr></table></figure>

<h2 id="useContext-（基础-hook）"><a href="#useContext-（基础-hook）" class="headerlink" title="useContext （基础 hook）"></a>useContext （基础 hook）</h2><p>Context 提供了一种在组件之间共享此类值的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const value &#x3D; useContext(MyContext);<br></code></pre></td></tr></table></figure>

<p>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。</p>
<p>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值</p>
<p>useContext(MyContext) 相当于 class 组件中的 static contextType = MyContext 或者 &lt;MyContext.Consumer&gt;。</p>
<p>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const themes &#x3D; &#123;<br>  light: &#123;<br>    foreground: &quot;#000000&quot;,<br>    background: &quot;#eeeeee&quot;<br>  &#125;,<br>  dark: &#123;<br>    foreground: &quot;#ffffff&quot;,<br>    background: &quot;#222222&quot;<br>  &#125;<br>&#125;;<br><br>const ThemeContext &#x3D; React.createContext(themes.light);<br><br>function App() &#123;<br>  return (<br>    &lt;ThemeContext.Provider value&#x3D;&#123;themes.dark&#125;&gt;<br>      &lt;Toolbar &#x2F;&gt;<br>    &lt;&#x2F;ThemeContext.Provider&gt;<br>  );<br>&#125;<br><br>function Toolbar(props) &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;ThemedButton &#x2F;&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;<br><br>function ThemedButton() &#123;<br>  const theme &#x3D; useContext(ThemeContext);<br>  return (<br>    &lt;button style&#x3D;&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;<br>      I am styled by theme context!<br>    &lt;&#x2F;button&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="useReducer-（扩展-hook）"><a href="#useReducer-（扩展-hook）" class="headerlink" title="useReducer （扩展 hook）"></a>useReducer （扩展 hook）</h2><p><strong>useState 的替代方案。</strong> 它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。<br>能在任何使用 useState 的地方都替换成使用 useReducer</p>
<h5 id="action-state为普通字符串-ex："><a href="#action-state为普通字符串-ex：" class="headerlink" title="action state为普通字符串 ex："></a>action state为普通字符串 ex：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const initialState &#x3D; &#123;count: 0&#125;;<br><br>function reducer(state, action) &#123;<br>  switch (action.type) &#123;<br>    case &#39;increment&#39;:<br>      return &#123;count: state.count + 1&#125;;<br>    case &#39;decrement&#39;:<br>      return &#123;count: state.count - 1&#125;;<br>    default:<br>      throw new Error();<br>  &#125;<br>&#125;<br><br>function Counter() &#123;<br>  const [state, dispatch] &#x3D; useReducer(reducer, initialState);<br>  return (<br>    &lt;&gt;<br>      Count: &#123;state.count&#125;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;<br>    &lt;&#x2F;&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="action-state为对象-ex："><a href="#action-state为对象-ex：" class="headerlink" title="action state为对象 ex："></a>action state为对象 ex：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const initialState &#x3D; &#123;<br>  count1: 0,<br>  count2: 0,<br>&#125;;<br>const reducer &#x3D; (state, action) &#x3D;&gt; &#123;<br>  switch (action.type) &#123;<br>    case &#39;increment1&#39;:<br>      return &#123; ...state, count1: state.count1 + 1 &#125;;<br>    case &#39;decrement1&#39;:<br>      return &#123; ...state, count1: state.count1 - 1 &#125;;<br>    case &#39;set1&#39;:<br>      return &#123; ...state, count1: action.count &#125;;<br>    case &#39;increment2&#39;:<br>      return &#123; ...state, count2: state.count2 + 1 &#125;;<br>    case &#39;decrement2&#39;:<br>      return &#123; ...state, count2: state.count2 - 1 &#125;;<br>    case &#39;set2&#39;:<br>      return &#123; ...state, count2: action.count &#125;;<br>    default:<br>      throw new Error(&#39;Unexpected action&#39;);<br>  &#125;<br>&#125;<br><br>const Example02 &#x3D; () &#x3D;&gt; &#123;<br>  const [state, dispatch] &#x3D; useReducer(reducer, initialState);<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        &#123;state.count1&#125;<br>        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;increment1&#39; &#125;)&#125;&gt;+1&lt;&#x2F;button&gt;<br>        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;decrement1&#39; &#125;)&#125;&gt;-1&lt;&#x2F;button&gt;<br>        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;set1&#39;, count: 0 &#125;)&#125;&gt;reset&lt;&#x2F;button&gt;<br>      &lt;&#x2F;div&gt;<br>      &lt;div&gt;<br>        &#123;state.count2&#125;<br>        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;increment2&#39; &#125;)&#125;&gt;+1&lt;&#x2F;button&gt;<br>        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;decrement2&#39; &#125;)&#125;&gt;-1&lt;&#x2F;button&gt;<br>        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;set2&#39;, count: 0 &#125;)&#125;&gt;reset&lt;&#x2F;button&gt;<br>      &lt;&#x2F;div&gt;<br>    &lt;&#x2F;&gt;<br>  );<br><br></code></pre></td></tr></table></figure>

<h5 id="结合context使用-ex："><a href="#结合context使用-ex：" class="headerlink" title="结合context使用 ex："></a>结合context使用 ex：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>const CountContext &#x3D; React.createContext();<br><br>const CountProvider &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;<br>  const contextValue &#x3D; useReducer(reducer, initialState);<br>  return (<br>    &lt;CountContext.Provider value&#x3D;&#123;contextValue&#125;&gt;<br>      &#123;children&#125;<br>    &lt;&#x2F;CountContext.Provider&gt;<br>  );<br>&#125;;<br><br>const useCount &#x3D; () &#x3D;&gt; &#123;<br>  const contextValue &#x3D; useContext(CountContext);<br>  return contextValue;<br><br>const Counter &#x3D; () &#x3D;&gt; &#123;<br>  const [count, dispatch] &#x3D; useCount();<br>  return (<br>    &lt;div&gt;<br>      &#123;count&#125;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;+1&lt;&#x2F;button&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;-1&lt;&#x2F;button&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;set&#39;, count: 0 &#125;)&#125;&gt;reset&lt;&#x2F;button&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="useMemo-（扩展-hook）"><a href="#useMemo-（扩展-hook）" class="headerlink" title="useMemo （扩展 hook）"></a>useMemo （扩展 hook）</h2><p>把 <strong>“创建”函数</strong> 和 <strong>依赖项数组</strong> 作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const memoizedValue &#x3D; useMemo(() &#x3D;&gt; computeExpensiveValue(a, b), [a, b]);<br></code></pre></td></tr></table></figure>
<p>可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。<br>传入 useMemo 的函数会在渲染期间执行。不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。<br>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</p>
<h2 id="useCallback-（扩展-hook）"><a href="#useCallback-（扩展-hook）" class="headerlink" title="useCallback （扩展 hook）"></a>useCallback （扩展 hook）</h2><p>把 <strong>内联回调函数</strong> 及 <strong>依赖项数组</strong> 作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const memoizedCallback &#x3D; useCallback(<br>  () &#x3D;&gt; &#123;<br>    doSomething(a, b);<br>  &#125;,<br>  [a, b],<br>);<br></code></pre></td></tr></table></figure>
<p>注: 依赖项数组不会作为参数传给回调函数。<br><strong>useCallback(fn, deps)  相当于  useMemo(() =&gt; fn, deps)</strong></p>
<h2 id="useRef-（扩展-hook）"><a href="#useRef-（扩展-hook）" class="headerlink" title="useRef （扩展 hook）"></a>useRef （扩展 hook）</h2><p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p>
<h5 id="第一种用法：作用于DOM元素"><a href="#第一种用法：作用于DOM元素" class="headerlink" title="第一种用法：作用于DOM元素"></a>第一种用法：作用于DOM元素</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const UseRefComp&#x3D;()&#x3D;&gt;&#123;<br>		&#x2F;&#x2F;创建ref<br>		const inputRef&#x3D;useRef()<br>		const getValue&#x3D; () &#x3D;&gt; &#123;<br>		&#x2F;&#x2F;访问ref<br>			console.log(inputRef.current.value) &#125;<br>		&#x2F;&#x2F;挂载<br>		return (<br>		&lt;div&gt;<br>		&lt;input ref&#x3D;&#123;inputRef&#125; type&#x3D;&quot;text&quot;&gt; &lt;button onClick&#x3D;&#123;getValue&#125;&gt;获取input的<br>		值&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;<br>) &#125;<br></code></pre></td></tr></table></figure>

<h5 id="第二种用法：在函数组件中的一个全局变量，不会因为重复-render-重复申明，-类似于类组件的this-xxx"><a href="#第二种用法：在函数组件中的一个全局变量，不会因为重复-render-重复申明，-类似于类组件的this-xxx" class="headerlink" title="第二种用法：在函数组件中的一个全局变量，不会因为重复 render 重复申明， 类似于类组件的this.xxx"></a>第二种用法：在函数组件中的一个全局变量，不会因为重复 render 重复申明， 类似于类组件的this.xxx</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">function Test()&#123;<br><br>const t&#x3D;useRef(null);<br><br>const handleClick &#x3D; ()&#x3D;&gt;&#123;<br>	t.current&#x3D;setTimeout(()&#x3D;&gt;&#123;<br>		console.log(&#39;timer&#39;)<br>	&#125;,1000)<br>&#125;<br>const handleClear &#x3D; () &#x3D;&gt; clearTimeout(t.current)<br><br>return (<br>	&lt;&gt;<br>		&lt;button onClick&#x3D;&#123;handleClick&#125;&gt;start&lt;&#x2F;button&gt;<br>		&lt;button onClick&#x3D;&#123;handleClear&#125;&gt;clear&lt;&#x2F;button&gt;<br>	&lt;&#x2F;&gt;<br>)&#125;<br></code></pre></td></tr></table></figure>

<h2 id="useImperativeHandle-（扩展-hook）"><a href="#useImperativeHandle-（扩展-hook）" class="headerlink" title="useImperativeHandle （扩展 hook）"></a>useImperativeHandle （扩展 hook）</h2><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 需要结合 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref">React.forwardRef</a>  一起使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 子组件<br>import &#123;useState, useImperativeHandle,forwardRef&#125; from &#39;react&#39;;<br><br>&#x2F;&#x2F; props子组件中需要接受ref<br>let ChildComp &#x3D; (props,ref) &#x3D;&gt; &#123;<br>    &#x2F;&#x2F; 此处注意useImperativeHandle方法的的第一个参数是目标元素的ref引用<br>    useImperativeHandle(ref, () &#x3D;&gt; (&#123;<br>        &#x2F;&#x2F; changeVal 就是暴露给父组件的方法<br>        changeVal: (newVal) &#x3D;&gt; &#123;<br><br>        &#125;<br>    &#125;));<br>    return (<br>        &lt;div&gt;&#123;val&#125;&lt;&#x2F;div&gt;<br>    )<br>&#125;<br><br><br>&#x2F;&#x2F; 父组件<br>import &#123;useRef&#125; from &#39;react&#39;;<br><br>const FComp &#x3D; () &#x3D;&gt; &#123;<br><br>    const childRef &#x3D; useRef();<br>    const updateChildState &#x3D; () &#x3D;&gt; &#123;<br>        &#x2F;&#x2F; changeVal就是子组件暴露给父组件的方法<br>        childRef.current.changeVal(99);<br>    &#125;<br><br>    return (<br>        &lt;&gt;<br>            &lt;ChildComp ref&#x3D;&#123;childRef&#125; &#x2F;&gt;<br>            &lt;button onClick&#x3D;&#123;updateChildState&#125;&gt;触发子组件方法&lt;&#x2F;button&gt;<br>        &lt;&#x2F;&gt;<br>    )<br><br></code></pre></td></tr></table></figure>

<h2 id="useLayoutEffect-（扩展-hook）"><a href="#useLayoutEffect-（扩展-hook）" class="headerlink" title="useLayoutEffect （扩展 hook）"></a>useLayoutEffect （扩展 hook）</h2><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。</p>
<p><strong>useEffect【异步】</strong><br>useEffect会在渲染的内容更新到DOM上后执行,不会阻塞DOM的更新<br><strong>useLayoutEffect【同步】</strong><br>useLayoutEffect会在渲染的内容更新到DOM上之前进行,会阻塞DOM的更新</p>
]]></content>
  </entry>
</search>
